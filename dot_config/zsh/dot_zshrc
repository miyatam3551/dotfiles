# ===============================================
# 基本環境変数 / Basic Environment Variables
# ===============================================

export LANG="en_US.UTF-8"
export EDITOR="vim"
export CLAUDE_CONFIG_DIR="$HOME/.config/claude"
export STARSHIP_CONFIG="$HOME/.config/starship.toml"
export KUBECONFIG="$HOME/.config/kube/config"
export AWS_PROFILE='private-dev'

# ===============================================
# vi-mode の設定
# ===============================================

# vi-mode を有効化
bindkey -v

# vi-mode のプロンプトインジケーター
# カーソルの形状変更（挿入モード: ビームカーソル、ノーマルモード: ブロックカーソル）
function zle-keymap-select {
    if [[ ${KEYMAP} == vicmd ]] || [[ $1 = 'block' ]]; then
        echo -ne '\e[1 q'  # ブロックカーソル
    elif [[ ${KEYMAP} == main ]] || [[ ${KEYMAP} == viins ]] || [[ ${KEYMAP} = '' ]] || [[ $1 = 'beam' ]]; then
        echo -ne '\e[5 q'  # ビームカーソル
    fi
}
zle -N zle-keymap-select

# 行の初期化時にビームカーソルに設定
function zle-line-init {
    zle -K viins  # 常に挿入モードで開始
    echo -ne '\e[5 q'
}
zle -N zle-line-init

# コマンド実行前にビームカーソルに戻す
preexec() {
    echo -ne '\e[5 q'
}

# ESCキーの遅延を減らす
export KEYTIMEOUT=1

# text objects を有効化（ciw, ci', ca" など）
autoload -Uz select-bracketed select-quoted
zle -N select-bracketed
zle -N select-quoted
for km in viopp visual; do
  for c in {a,i}${(s..)^:-\'\"\`\|,./:;=+@}; do
    bindkey -M $km $c select-quoted
  done
  for c in {a,i}${(s..)^:-'()[]{}<>bB'}; do
    bindkey -M $km $c select-bracketed
  done
done

bindkey -M viins '^?' backward-delete-char  # Backspace
bindkey -M viins '^H' backward-delete-char  # Ctrl+H
bindkey -M viins '^W' backward-kill-word    # Ctrl+W で単語削除
bindkey -M viins '^U' backward-kill-line    # Ctrl+U で行頭まで削除

# ===============================================
# 履歴設定 / History Configuration
# ===============================================

HISTFILE=~/.zsh_history
HISTSIZE=100000
SAVEHIST=100000

# 履歴オプション
setopt SHARE_HISTORY           # 複数のターミナル間で履歴を共有
setopt HIST_IGNORE_DUPS        # 重複したコマンドを履歴に追加しない
setopt HIST_IGNORE_ALL_DUPS    # 古い重複エントリを削除
setopt HIST_FIND_NO_DUPS       # 履歴検索で重複を表示しない
setopt HIST_IGNORE_SPACE       # スペースで始まるコマンドを履歴に追加しない
setopt HIST_SAVE_NO_DUPS       # 保存時に重複を除外
setopt HIST_REDUCE_BLANKS      # 余分な空白を削除

# ===============================================
# パス設定 / PATH Configuration
# ===============================================

# PATHに追加（重複を避ける）
typeset -U path  # 重複を自動削除

# Cargo (Rust)
if [[ -d "$HOME/.cargo/bin" ]]; then
    path=("$HOME/.cargo/bin" $path)
fi

# uv, pipx など
if [[ -d "$HOME/.local/bin" ]]; then
    path=("$HOME/.local/bin" $path)
fi

# Go
if [[ -d "$HOME/go/bin" ]]; then
    path=("$HOME/go/bin" $path)
fi

# ===============================================
# Homebrew
# ===============================================

if [[ ! -d "/opt/homebrew" ]]; then
    echo "Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
fi

if [[ -d "/opt/homebrew" ]]; then
    path=("/opt/homebrew/bin" $path)
    export HOMEBREW_PREFIX="/opt/homebrew"
    export HOMEBREW_CELLAR="/opt/homebrew/Cellar"
    export HOMEBREW_REPOSITORY="/opt/homebrew"
    export MANPATH="/opt/homebrew/share/man${MANPATH+:$MANPATH}:"
    export INFOPATH="/opt/homebrew/share/info${INFOPATH+:$INFOPATH}"
fi

# ===============================================
# mise (ランタイムバージョン管理)
# ===============================================

if command -v mise &> /dev/null; then
    eval "$(mise activate zsh)"
fi

# ===============================================
# Starship プロンプト
# ===============================================

if command -v starship &> /dev/null; then
    eval "$(starship init zsh)"
fi

# ===============================================
# zoxide (z の代替)
# ===============================================

if ! command -v zoxide &> /dev/null; then
    echo "Installing zoxide..."
    brew install zoxide
fi
eval "$(zoxide init zsh)"

# ===============================================
# fzf の設定
# ===============================================

if command -v fzf &> /dev/null; then
    # fzf key bindings and completion
    if [[ -f ~/.fzf.zsh ]]; then
        source ~/.fzf.zsh
    elif [[ -f /opt/homebrew/opt/fzf/shell/key-bindings.zsh ]]; then
        source /opt/homebrew/opt/fzf/shell/key-bindings.zsh
        source /opt/homebrew/opt/fzf/shell/completion.zsh
    fi

    # fzf のデフォルトオプション
    export FZF_DEFAULT_OPTS="--height 40% --layout=reverse --border"
fi

# ===============================================
# zsh-autosuggestions (履歴からの候補表示)
# ===============================================

if [[ ! -f /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
    echo "Installing zsh-autosuggestions..."
    brew install zsh-autosuggestions
fi
source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh
# 候補の色を明るくする (fg=色番号 または fg=#RRGGBB)
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=244'  # TODO(human): 好みの色に調整

# ===============================================
# zsh-syntax-highlighting (コマンド色分け)
# ===============================================

if [[ ! -f /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then
    echo "Installing zsh-syntax-highlighting..."
    brew install zsh-syntax-highlighting
fi
source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# 色のカスタマイズ
# 存在しないコマンド: グリーン（入力途中の状態）
ZSH_HIGHLIGHT_STYLES[unknown-token]='fg=green'
# 存在するコマンド: 青・太字
ZSH_HIGHLIGHT_STYLES[command]='fg=blue,bold'
# エイリアス: 青・太字
ZSH_HIGHLIGHT_STYLES[alias]='fg=blue,bold'
# ビルトインコマンド: 青・太字
ZSH_HIGHLIGHT_STYLES[builtin]='fg=blue,bold'
# 関数: 青・太字
ZSH_HIGHLIGHT_STYLES[function]='fg=blue,bold'
# パス: シアン・太字（存在するパス）
ZSH_HIGHLIGHT_STYLES[path]='fg=cyan,bold'
# 引数（サブコマンド含む）: シアン・細字
ZSH_HIGHLIGHT_STYLES[default]='fg=cyan'

# ===============================================
# zsh-abbr (fishライクな省略形展開)
# ===============================================

if [[ ! -d ~/.local/share/zsh-abbr ]]; then
    echo "Installing zsh-abbr..."
    git clone --recursive https://github.com/olets/zsh-abbr.git ~/.local/share/zsh-abbr
fi
source ~/.local/share/zsh-abbr/zsh-abbr.zsh

# ===============================================
# alias の設定
# ===============================================
alias ls='lsd'
alias ll='lsd -la --group-directories-first --no-symlink'
alias lls='lsd -la -t'


# ===============================================
# yazi の設定
# yazi を閉じた時に cd を反映させる
# ===============================================
function y() {
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
    yazi "$@" --cwd-file="$tmp"
    if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
        cd -- "$cwd"
    fi
    rm -f -- "$tmp"
}

# ===============================================
# mkcd の設定
# ディレクトリを作成して移動
# ===============================================
function mkcd() {
    mkdir -p "$1" && cd "$1"
}

# ===============================================
# ripgrep-edit の設定
# rg で検索 → fzf で選択 → vim で開く
# ===============================================
function ripgrep-edit() {
    if [[ -z "$1" ]]; then
        echo "Usage: ripgrep-edit <pattern> [rg options]"
        return 1
    fi

    # rg で検索して fzf に渡す
    local result=$(rg --line-number --no-heading --color=always "$@" | \
        fzf --ansi --delimiter ':' \
            --preview 'bat --color=always --highlight-line {2} {1} 2>/dev/null || head -100 {1}' \
            --preview-window 'up,50%,+{2}-5')

    if [[ -n "$result" ]]; then
        local file=$(echo "$result" | cut -d':' -f1)
        local line=$(echo "$result" | cut -d':' -f2)
        vim "+$line" "$file"
    fi
}

# ===============================================
# cdh の設定
# ディレクトリ履歴から fzf で選択して移動
# ===============================================
CD_HISTORY_FILE="$HOME/.config/nushell/cd_history.txt"

# cd時に履歴に記録
function chpwd() {
    # 履歴ファイルが存在しない場合は作成
    [[ -d "$(dirname "$CD_HISTORY_FILE")" ]] || mkdir -p "$(dirname "$CD_HISTORY_FILE")"
    echo "$PWD" >> "$CD_HISTORY_FILE"
}

# 履歴からfzfで選択してcd
function cdh() {
    if [[ ! -f "$CD_HISTORY_FILE" ]]; then
        echo "履歴ファイルが存在しません: $CD_HISTORY_FILE"
        return 1
    fi

    local selected=$(tac "$CD_HISTORY_FILE" | awk '!seen[$0]++' | fzf --height 40% --reverse --prompt "cd > ")
    if [[ -n "$selected" ]]; then
        cd "$selected"
    fi
}

# ===============================================
# ssm-params の設定
# AWS SSM Parameter Store からパラメータ一覧を取得
# ===============================================
function ssm-params() {
    aws ssm describe-parameters | jq -r '.Parameters[] | [.Name, .Type, .LastModifiedDate] | @tsv' | column -t
}

# ===============================================
# ghq 連携関数 / ghq Integration Functions
# ===============================================

# ===============================================
# リポジトリ検索・移動
# fzf を使用してリポジトリをfuzzy検索し、選択したリポジトリに移動
# ===============================================
function repos() {
    if ! command -v ghq &> /dev/null; then
        echo "Error: ghq is not installed"
        return 1
    fi

    if ! command -v fzf &> /dev/null; then
        echo "Error: fzf is not installed"
        return 1
    fi

    # プレビューコマンドを構築（ezaがあれば使用、なければls）
    local preview_cmd
    if command -v eza &> /dev/null; then
        preview_cmd="ghq list --full-path --exact {} | xargs eza --tree --level=2"
    else
        preview_cmd="ghq list --full-path --exact {} | xargs ls -la"
    fi

    local repo=$(ghq list | fzf --preview="$preview_cmd")
    if [[ -n "$repo" ]]; then
        local repo_path=$(ghq list --full-path | grep "$repo" | head -n 1)
        cd "$repo_path"
    fi
}

# ===============================================
# ghqルートディレクトリに移動
# ===============================================
function ghq-root() {
    if ! command -v ghq &> /dev/null; then
        echo "Error: ghq is not installed"
        return 1
    fi

    local ghq_root=$(ghq root)
    cd "$ghq_root"
}

# ===============================================
# リポジトリルートに移動
# サブディレクトリからリポジトリのルートに移動
# ===============================================
function repo-root() {
    local root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -z "$root" ]]; then
        echo "Error: 現在のディレクトリはGitリポジトリではありません"
        return 1
    fi
    cd "$root"
}

# ===============================================
# リポジトリをクローン
# ghq get のラッパー。GitHub shorthand（user/repo）またはURLを指定
# ===============================================
function repo-clone() {
    if ! command -v ghq &> /dev/null; then
        echo "Error: ghq is not installed"
        return 1
    fi

    local repo="$1"
    local update_flag=""

    # -u または --update フラグをチェック
    if [[ "$2" == "-u" || "$2" == "--update" ]]; then
        update_flag="-u"
    fi

    if [[ -z "$repo" ]]; then
        echo "Usage: repo-clone <repo> [-u|--update]"
        return 1
    fi

    # shorthand形式（user/repo）かどうかを判定
    local is_shorthand=false
    if [[ "$repo" == */* ]] && [[ "$repo" != git@* ]] && [[ "$repo" != http* ]]; then
        is_shorthand=true
    fi

    local clone_url="$repo"

    if [[ "$is_shorthand" == true ]]; then
        # ~/.ssh/config からGitHubホストを取得
        local github_hosts=($(grep "^Host github" ~/.ssh/config 2>/dev/null | awk '{print $2}'))

        if [[ ${#github_hosts[@]} -eq 0 ]]; then
            echo "エラー: ~/.ssh/config にGitHubホストが見つかりません"
            return 1
        fi

        local selected_host
        if [[ ${#github_hosts[@]} -gt 1 ]]; then
            # 複数ある場合は選択させる（fzfを使用）
            if command -v fzf &> /dev/null; then
                selected_host=$(printf "%s\n" "${github_hosts[@]}" | fzf --prompt "GitHubアカウントを選択: ")
            else
                selected_host="${github_hosts[1]}"
            fi
        else
            selected_host="${github_hosts[1]}"
        fi

        if [[ -z "$selected_host" ]]; then
            return 1
        fi

        # SSH URL形式に変換
        clone_url="git@${selected_host}:${repo}.git"
    fi

    # クローン実行
    if [[ -n "$update_flag" ]]; then
        ghq get -u "$clone_url"
    else
        ghq get "$clone_url"
    fi

    # クローン後、そのディレクトリに移動
    local repo_name=$(basename "$repo" .git)
    local repo_path=$(ghq list --full-path | grep "$repo_name" | head -n 1)

    if [[ -n "$repo_path" ]]; then
        echo "リポジトリをクローンしました: $repo_path"
        cd "$repo_path"
    fi
}

# ===============================================
# 現在のリポジトリ情報を表示
# パス、origin URL、現在のブランチ、リモートブランチなどを表示
# ===============================================
function repo-info() {
    if [[ ! -d ".git" ]]; then
        echo "現在のディレクトリはGitリポジトリではありません"
        return 1
    fi

    local repo_path=$(pwd)
    local ghq_root=$(ghq root 2>/dev/null)

    # ghq管理下かチェック
    local is_ghq_repo="false"
    if [[ -n "$ghq_root" ]] && [[ "$repo_path" == "$ghq_root"* ]]; then
        is_ghq_repo="true"
    fi

    # Git情報を取得
    local branch=$(git branch --show-current 2>/dev/null)
    local origin=$(git remote get-url origin 2>/dev/null)
    local remote_branch=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null)

    echo "=== リポジトリ情報 ==="
    echo "パス: $repo_path"
    echo "ghq管理: $is_ghq_repo"
    echo "Origin: $origin"
    echo "現在のブランチ: $branch"
    if [[ -n "$remote_branch" ]]; then
        echo "リモートブランチ: $remote_branch"
    fi

    # コミット状態
    local status=$(git status --short 2>/dev/null)
    if [[ -z "$status" ]]; then
        echo "ステータス: クリーン (変更なし)"
    else
        echo "ステータス: 変更あり"
        echo "$status"
    fi
}

# ===============================================
# 7zz の設定
# fzf を使用して 7z の圧縮・解凍を選択式で実行
# ===============================================
function 7zz() {
    # 7z コマンドの存在確認
    if ! command -v 7z &> /dev/null; then
        echo "Error: 7z is not installed"
        echo "Install with: brew install p7zip"
        return 1
    fi

    # fzf コマンドの存在確認
    if ! command -v fzf &> /dev/null; then
        echo "Error: fzf is not installed"
        return 1
    fi

    # 引数がある場合：拡張子で圧縮/解凍を自動判定
    if [[ -n "$1" ]]; then
        if [[ "$1" =~ \.(7z|zip|tar\.gz|tgz|tar\.bz2|tar\.xz|rar|gz|bz2|xz)$ ]]; then
            # アーカイブファイル → 解凍
            _7zz_extract_file "$1"
        else
            # それ以外 → 圧縮
            _7zz_compress_file "$1"
        fi
        return
    fi

    # 引数なし：従来のメニュー選択
    local action=$(printf '%s\n' "compress" "extract" "list" | \
        fzf --header "7z インタラクティブモード - 操作を選択してください" \
            --height 20% --reverse)

    [[ -z "$action" ]] && return 0

    case "$action" in
        "compress")
            _7zz_compress
            ;;
        "extract")
            _7zz_extract
            ;;
        "list")
            _7zz_list
            ;;
    esac
}

# 圧縮サブ関数
function _7zz_compress() {
    # ファイル/フォルダを選択（複数選択可）
    local selected=$(ls -A | fzf --multi \
        --header "圧縮するファイル/フォルダを選択 (Tab: 複数選択, Enter: 確定)" \
        --preview 'if [[ -d {} ]]; then ls -la {}; else file {} && head -20 {}; fi' \
        --preview-window 'right,50%')

    [[ -z "$selected" ]] && return 0

    # 選択されたファイルを配列に変換
    local -a files
    files=("${(@f)selected}")

    # 圧縮形式を選択
    local format=$(printf '%s\n' "7z" "zip" | fzf --header "圧縮形式を選択" --height=~50%)
    [[ -z "$format" ]] && return 0

    # デフォルトの出力ファイル名（最初の選択ファイル名.形式）
    local default_name="${files[1]}.${format}"

    # 出力ファイル名を入力
    echo -n "出力ファイル名 [$default_name]: "
    read output_name
    output_name="${output_name:-$default_name}"

    # 拡張子がなければ追加
    [[ "$output_name" != *."$format" ]] && output_name="${output_name}.${format}"

    # 圧縮実行
    echo "圧縮中: ${files[*]} -> $output_name"
    7z a "$output_name" "${files[@]}"

    if [[ $? -eq 0 ]]; then
        echo "圧縮完了: $output_name"
        ls -lh "$output_name"
    else
        echo "圧縮に失敗しました"
        return 1
    fi
}

# 引数指定での圧縮サブ関数
function _7zz_compress_file() {
    local target="$1"

    if [[ ! -e "$target" ]]; then
        echo "ファイル/フォルダが見つかりません: $target"
        return 1
    fi

    # 圧縮形式を選択
    local format=$(printf '%s\n' "7z" "zip" | fzf --header "圧縮形式を選択" --height=~50%)
    [[ -z "$format" ]] && return 0

    local output_name="${target}.${format}"

    echo "圧縮中: $target -> $output_name"
    7z a "$output_name" "$target"

    if [[ $? -eq 0 ]]; then
        echo "圧縮完了: $output_name"
        ls -lh "$output_name"
    else
        echo "圧縮に失敗しました"
        return 1
    fi
}

# 引数指定での解凍サブ関数
function _7zz_extract_file() {
    local archive="$1"

    if [[ ! -f "$archive" ]]; then
        echo "アーカイブが見つかりません: $archive"
        return 1
    fi

    # アーカイブ名から拡張子を除去してフォルダ名を作成
    local folder="${archive%.*}"
    # 二重拡張子対応（.tar.gz など）
    [[ "$folder" == *.tar ]] && folder="${folder%.tar}"

    echo "解凍中: $archive → $folder/"
    mkdir -p "$folder"
    7z x -o"$folder" "$archive"

    if [[ $? -eq 0 ]]; then
        echo "解凍完了: $folder/"
    else
        echo "解凍に失敗しました"
        return 1
    fi
}

# 解凍サブ関数（fzf選択版）
function _7zz_extract() {
    # 圧縮ファイルを検索
    local archives=$(ls -1 2>/dev/null | grep -E '\.(7z|zip|tar\.gz|tgz|tar\.bz2|tar\.xz|rar|gz|bz2|xz)$')

    if [[ -z "$archives" ]]; then
        echo "カレントディレクトリに圧縮ファイルが見つかりません"
        return 1
    fi

    # アーカイブを選択（プレビューで中身を表示）
    local selected=$(echo "$archives" | fzf \
        --header "解凍するアーカイブを選択" \
        --preview '7z l {} 2>/dev/null | tail -30' \
        --preview-window 'right,60%')

    [[ -z "$selected" ]] && return 0

    # アーカイブ名から拡張子を除去してフォルダ名を作成
    local folder="${selected%.*}"
    # 二重拡張子対応（.tar.gz など）
    [[ "$folder" == *.tar ]] && folder="${folder%.tar}"

    # 解凍実行
    echo "解凍中: $selected → $folder/"
    mkdir -p "$folder"
    7z x -o"$folder" "$selected"

    if [[ $? -eq 0 ]]; then
        echo "解凍完了"
    else
        echo "解凍に失敗しました"
        return 1
    fi
}

# 一覧表示サブ関数
function _7zz_list() {
    # 圧縮ファイルを検索
    local archives=$(ls -1 2>/dev/null | grep -E '\.(7z|zip|tar\.gz|tgz|tar\.bz2|tar\.xz|rar|gz|bz2|xz)$')

    if [[ -z "$archives" ]]; then
        echo "カレントディレクトリに圧縮ファイルが見つかりません"
        return 1
    fi

    # アーカイブを選択
    local selected=$(echo "$archives" | fzf \
        --header "一覧表示するアーカイブを選択" \
        --preview '7z l {} 2>/dev/null | tail -30' \
        --preview-window 'right,60%')

    [[ -z "$selected" ]] && return 0

    # 一覧表示
    7z l "$selected"
}

# ===============================================
# MCP テンプレート切り替え
# fzf を使用して MCP 設定テンプレートを選択
# ===============================================
function mcpset() {
    local templates_dir="$HOME/.config/claude/.mcp-templates"
    local target="$HOME/obsidian/.mcp.json"

    # テンプレートディレクトリの確認
    if [[ ! -d "$templates_dir" ]]; then
        echo "Error: テンプレートディレクトリが見つかりません: $templates_dir"
        return 1
    fi

    # fzf でテンプレートを選択
    local selected=$(ls "$templates_dir"/*.mcp.json 2>/dev/null | \
        xargs -n1 basename | \
        fzf --header "MCP テンプレートを選択" --height 40% --reverse)

    [[ -z "$selected" ]] && return 0

    # シンボリックリンクを作成（既存リンクは上書き）
    ln -sf "$templates_dir/$selected" "$target"

    echo "MCP テンプレートを切り替えました: $selected"
    ls -la "$target"
}

# ===============================================
# エイリアス設定 / Aliases
# ===============================================

# AI/開発ツール
alias cc='claude'
alias mcp='mcpset'

# Python/パッケージ管理
alias python='python3'

# インフラツール
alias mp='multipass'
alias awsso='aws sso login --use-device-code --no-browser'

# ユーティリティ
alias cl='clear'

# ghq (リポジトリ管理)
alias gr='repos'
alias grr='ghq-root'
alias grc='repo-clone'
alias gri='repo-info'
alias grt='repo-root'

# mkcd (in functions)
alias mcd='mkcd'

# ripgrep-edit (rg + fzf + vim)
alias re='ripgrep-edit'

# tmuxinator (セッション管理)
alias mux='tmuxinator'
alias muxs='tmuxinator start'
alias muxo='tmuxinator stop'
alias muxe='tmuxinator edit'
alias muxl='tmuxinator list'

# prettier (json, md, yaml をフォーマット)
alias fmt='prettier --write "**/*.{json,md,yml,yaml}"'

# ===============================================
# 補完設定 / Completion Configuration
# ===============================================

# 補完機能を有効化
autoload -Uz compinit
compinit

# 補完オプション
setopt AUTO_LIST           # 補完候補を一覧表示
setopt AUTO_MENU           # 補完候補をメニューから選択
setopt LIST_PACKED         # 補完候補を詰めて表示
setopt COMPLETE_IN_WORD    # 単語の途中でも補完
setopt ALWAYS_TO_END       # 補完後にカーソルを末尾に移動

# 大文字小文字を区別しない補完
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# 補完候補をカラー表示
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"

# ===============================================
# その他のオプション / Other Options
# ===============================================

# ディレクトリ移動
setopt AUTO_CD             # ディレクトリ名だけで移動
setopt AUTO_PUSHD          # cd時に自動でpushdを実行
setopt PUSHD_IGNORE_DUPS   # pushdで重複を無視

# エラー訂正
setopt CORRECT             # コマンドのスペル訂正

# グロブ
setopt EXTENDED_GLOB       # 拡張グロブを有効化

# ===============================================
# tmux 自動起動 (tmuxinator)
# ===============================================
# ターミナル起動時に tmuxinator で work/private セッションを起動
# -z "$TMUX"       : tmux内でない（無限ループ防止）
# -t 0             : 標準入力がTTY（スクリプトやパイプ経由での起動を除外）
if [[ -z "$TMUX" ]] && [[ -t 0 ]]; then
    # 両方のセッションを起動（存在しなければ作成）
    tmux has-session -t work 2>/dev/null || tmuxinator start work -d
    tmux has-session -t private 2>/dev/null || tmuxinator start private -d
    # work にアタッチ
    tmux attach -t work
fi
